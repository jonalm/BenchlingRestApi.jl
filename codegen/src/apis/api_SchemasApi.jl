# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct SchemasApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `SchemasApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ SchemasApi }) = "/api/v2"

const _returntypes_get_batch_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_batch_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_batch_schema_SchemasApi, "/batch-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a batch schema by ID

Get a batch schema by ID

Params:
- schema_id::String (required)

Return: BatchSchema, OpenAPI.Clients.ApiResponse
"""
function get_batch_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_batch_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_batch_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_batch_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_box_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BoxSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_box_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_box_schema_SchemasApi, "/box-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a box schema by ID

Get a box schema by ID

Params:
- schema_id::String (required)

Return: BoxSchema, OpenAPI.Clients.ApiResponse
"""
function get_box_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_box_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_box_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_box_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_container_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainerSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_container_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_container_schema_SchemasApi, "/container-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a container schema by ID

Get a container schema by ID

Params:
- schema_id::String (required)

Return: ContainerSchema, OpenAPI.Clients.ApiResponse
"""
function get_container_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_container_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_container_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_container_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_entity_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => EntitySchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_entity_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_entity_schema_SchemasApi, "/entity-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get an entity schema by ID

Get an entity schema by ID

Params:
- schema_id::String (required)

Return: EntitySchema, OpenAPI.Clients.ApiResponse
"""
function get_entity_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_entity_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_entity_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_entity_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_entry_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => EntrySchemaDetailed,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_entry_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_entry_schema_SchemasApi, "/entry-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get an Entry schema by ID

Get an Entry schema by ID

Params:
- schema_id::String (required)

Return: EntrySchemaDetailed, OpenAPI.Clients.ApiResponse
"""
function get_entry_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_entry_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_entry_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_entry_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_location_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => LocationSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_location_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_location_schema_SchemasApi, "/location-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a location schema by ID

Get a location schema by ID

Params:
- schema_id::String (required)

Return: LocationSchema, OpenAPI.Clients.ApiResponse
"""
function get_location_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_location_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_location_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_location_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_plate_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PlateSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_plate_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_plate_schema_SchemasApi, "/plate-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a plate schema by ID

Get a plate schema by ID

Params:
- schema_id::String (required)

Return: PlateSchema, OpenAPI.Clients.ApiResponse
"""
function get_plate_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_plate_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_plate_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_plate_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_request_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => RequestSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_request_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_request_schema_SchemasApi, "/request-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a Request schema by ID

Get a Request schema by ID

Params:
- schema_id::String (required)

Return: RequestSchema, OpenAPI.Clients.ApiResponse
"""
function get_request_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_request_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_request_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_request_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_request_task_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => RequestTaskSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_request_task_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_request_task_schema_SchemasApi, "/request-task-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a Request Task schema by ID

Get a Request Task schema by ID

Params:
- schema_id::String (required)

Return: RequestTaskSchema, OpenAPI.Clients.ApiResponse
"""
function get_request_task_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_request_task_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_request_task_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_request_task_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_result_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => AssayResultSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_result_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_result_schema_SchemasApi, "/assay-result-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a Result schema by ID

Get a Result schema by ID

Params:
- schema_id::String (required)

Return: AssayResultSchema, OpenAPI.Clients.ApiResponse
"""
function get_result_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_result_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_result_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_result_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_run_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => AssayRunSchema,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_run_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_run_schema_SchemasApi, "/assay-run-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a Run schema by ID

Get a Run schema by ID

Params:
- schema_id::String (required)

Return: AssayRunSchema, OpenAPI.Clients.ApiResponse
"""
function get_run_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_run_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_run_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_run_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_workflow_task_schema_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => WorkflowTaskSchema,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_workflow_task_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_workflow_task_schema_SchemasApi, "/workflow-task-schemas/{schema_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "schema_id", schema_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a workflow task schema

Get a workflow task schema

Params:
- schema_id::String (required)

Return: WorkflowTaskSchema, OpenAPI.Clients.ApiResponse
"""
function get_workflow_task_schema(_api::SchemasApi, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_workflow_task_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_workflow_task_schema(_api::SchemasApi, response_stream::Channel, schema_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_workflow_task_schema(_api, schema_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_assay_result_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => AssayResultSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_assay_result_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_assay_result_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_assay_result_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_assay_result_schemas_SchemasApi, "/assay-result-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List assay result schemas

List assay result schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: AssayResultSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_assay_result_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_assay_result_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_assay_result_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_assay_result_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_assay_run_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => AssayRunSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_assay_run_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_assay_run_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_assay_run_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_assay_run_schemas_SchemasApi, "/assay-run-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List assay run schemas

List assay run schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: AssayRunSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_assay_run_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_assay_run_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_assay_run_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_assay_run_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_batch_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_batch_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_batch_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_batch_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_batch_schemas_SchemasApi, "/batch-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List batch schemas

List batch schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: BatchSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_batch_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_batch_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_batch_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_batch_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_box_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BoxSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_box_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_box_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_box_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_box_schemas_SchemasApi, "/box-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List box schemas

List box schemas

Params:
- next_token::String
- page_size::Int64

Return: BoxSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_box_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_box_schemas(_api; next_token=next_token, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_box_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_box_schemas(_api; next_token=next_token, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_container_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainerSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_container_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_container_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_container_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_container_schemas_SchemasApi, "/container-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List container schemas

List container schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: ContainerSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_container_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_container_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_container_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_container_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_entity_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => EntitySchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_entity_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_entity_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_entity_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_entity_schemas_SchemasApi, "/entity-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List entity schemas

List entity schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: EntitySchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_entity_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_entity_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_entity_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_entity_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_entry_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => EntrySchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_entry_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_entry_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_entry_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_entry_schemas_SchemasApi, "/entry-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List entry schemas

List entry schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: EntrySchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_entry_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_entry_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_entry_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_entry_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_location_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => LocationSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_location_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_location_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_location_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_location_schemas_SchemasApi, "/location-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List location schemas

List location schemas

Params:
- next_token::String
- page_size::Int64

Return: LocationSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_location_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_location_schemas(_api; next_token=next_token, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_location_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_location_schemas(_api; next_token=next_token, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_plate_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PlateSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_plate_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_plate_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_plate_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_plate_schemas_SchemasApi, "/plate-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List plate schemas

List plate schemas

Params:
- next_token::String
- page_size::Int64

Return: PlateSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_plate_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_plate_schemas(_api; next_token=next_token, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_plate_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_plate_schemas(_api; next_token=next_token, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_request_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => RequestSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_request_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_request_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_request_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_request_schemas_SchemasApi, "/request-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List request schemas

List request schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: RequestSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_request_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_request_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_request_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_request_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_request_task_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => RequestTaskSchemasPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_list_request_task_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_request_task_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_request_task_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_request_task_schemas_SchemasApi, "/request-task-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List request task schemas

List request task schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: RequestTaskSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_request_task_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_request_task_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_request_task_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_request_task_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_workflow_task_schemas_SchemasApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => WorkflowTaskSchemasPaginatedList,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_list_workflow_task_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_workflow_task_schemas", :maximum, page_size, 100, false)
    OpenAPI.validate_param("page_size", "list_workflow_task_schemas", :minimum, page_size, 0, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_workflow_task_schemas_SchemasApi, "/workflow-task-schemas", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List workflow task schemas

List workflow task schemas

Params:
- next_token::String
- page_size::Int64
- modified_at::String

Return: WorkflowTaskSchemasPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_workflow_task_schemas(_api::SchemasApi; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_workflow_task_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_workflow_task_schemas(_api::SchemasApi, response_stream::Channel; next_token=nothing, page_size=nothing, modified_at=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_workflow_task_schemas(_api; next_token=next_token, page_size=page_size, modified_at=modified_at, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export get_batch_schema
export get_box_schema
export get_container_schema
export get_entity_schema
export get_entry_schema
export get_location_schema
export get_plate_schema
export get_request_schema
export get_request_task_schema
export get_result_schema
export get_run_schema
export get_workflow_task_schema
export list_assay_result_schemas
export list_assay_run_schemas
export list_batch_schemas
export list_box_schemas
export list_container_schemas
export list_entity_schemas
export list_entry_schemas
export list_location_schemas
export list_plate_schemas
export list_request_schemas
export list_request_task_schemas
export list_workflow_task_schemas
