# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct ContainersApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `ContainersApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ ContainersApi }) = "/api/v2"

const _returntypes_archive_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainersArchivalChange,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
)

function _oacinternal_archive_containers(_api::ContainersApi; containers_archive=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_archive_containers_ContainersApi, "/containers:archive", ["basicApiKeyAuth", "oAuth", ], containers_archive)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Archive containers

Archive containers

Params:
- containers_archive::ContainersArchive

Return: ContainersArchivalChange, OpenAPI.Clients.ApiResponse
"""
function archive_containers(_api::ContainersApi; containers_archive=nothing, _mediaType=nothing)
    _ctx = _oacinternal_archive_containers(_api; containers_archive=containers_archive, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function archive_containers(_api::ContainersApi, response_stream::Channel; containers_archive=nothing, _mediaType=nothing)
    _ctx = _oacinternal_archive_containers(_api; containers_archive=containers_archive, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_bulk_create_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("202", "x"=>".") * "\$") => AsyncTaskLink,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_bulk_create_containers(_api::ContainersApi; containers_bulk_create_request=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_bulk_create_containers_ContainersApi, "/containers:bulk-create", ["basicApiKeyAuth", "oAuth", ], containers_bulk_create_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Bulk create containers. Limit of 1000 containers per request.

Bulk create containers

Params:
- containers_bulk_create_request::ContainersBulkCreateRequest

Return: AsyncTaskLink, OpenAPI.Clients.ApiResponse
"""
function bulk_create_containers(_api::ContainersApi; containers_bulk_create_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_bulk_create_containers(_api; containers_bulk_create_request=containers_bulk_create_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function bulk_create_containers(_api::ContainersApi, response_stream::Channel; containers_bulk_create_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_bulk_create_containers(_api; containers_bulk_create_request=containers_bulk_create_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_bulk_get_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainersList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_bulk_get_containers(_api::ContainersApi; container_ids=nothing, barcodes=nothing, returning=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_bulk_get_containers_ContainersApi, "/containers:bulk-get", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "containerIds", container_ids)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "barcodes", barcodes)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "returning", returning)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Bulk get a set of containers

Bulk get a set of containers. Provide either containerIds or barcodes, not both.

Params:
- container_ids::String
- barcodes::String
- returning::String

Return: ContainersList, OpenAPI.Clients.ApiResponse
"""
function bulk_get_containers(_api::ContainersApi; container_ids=nothing, barcodes=nothing, returning=nothing, _mediaType=nothing)
    _ctx = _oacinternal_bulk_get_containers(_api; container_ids=container_ids, barcodes=barcodes, returning=returning, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function bulk_get_containers(_api::ContainersApi, response_stream::Channel; container_ids=nothing, barcodes=nothing, returning=nothing, _mediaType=nothing)
    _ctx = _oacinternal_bulk_get_containers(_api; container_ids=container_ids, barcodes=barcodes, returning=returning, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_bulk_update_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("202", "x"=>".") * "\$") => AsyncTaskLink,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_bulk_update_containers(_api::ContainersApi; containers_bulk_update_request=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_bulk_update_containers_ContainersApi, "/containers:bulk-update", ["basicApiKeyAuth", "oAuth", ], containers_bulk_update_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Bulk update containers

Bulk update containers

Params:
- containers_bulk_update_request::ContainersBulkUpdateRequest

Return: AsyncTaskLink, OpenAPI.Clients.ApiResponse
"""
function bulk_update_containers(_api::ContainersApi; containers_bulk_update_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_bulk_update_containers(_api; containers_bulk_update_request=containers_bulk_update_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function bulk_update_containers(_api::ContainersApi, response_stream::Channel; containers_bulk_update_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_bulk_update_containers(_api; containers_bulk_update_request=containers_bulk_update_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_checkin_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Any,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
)

function _oacinternal_checkin_containers(_api::ContainersApi; containers_checkin=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_checkin_containers_ContainersApi, "/containers:check-in", ["basicApiKeyAuth", "oAuth", ], containers_checkin)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Check in containers

Check in containers to signify that they are available for use.

Params:
- containers_checkin::ContainersCheckin

Return: Any, OpenAPI.Clients.ApiResponse
"""
function checkin_containers(_api::ContainersApi; containers_checkin=nothing, _mediaType=nothing)
    _ctx = _oacinternal_checkin_containers(_api; containers_checkin=containers_checkin, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function checkin_containers(_api::ContainersApi, response_stream::Channel; containers_checkin=nothing, _mediaType=nothing)
    _ctx = _oacinternal_checkin_containers(_api; containers_checkin=containers_checkin, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_checkout_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Any,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
)

function _oacinternal_checkout_containers(_api::ContainersApi; containers_checkout=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_checkout_containers_ContainersApi, "/containers:check-out", ["basicApiKeyAuth", "oAuth", ], containers_checkout)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Check out containers

Check out containers to signify that they are in use.

Params:
- containers_checkout::ContainersCheckout

Return: Any, OpenAPI.Clients.ApiResponse
"""
function checkout_containers(_api::ContainersApi; containers_checkout=nothing, _mediaType=nothing)
    _ctx = _oacinternal_checkout_containers(_api; containers_checkout=containers_checkout, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function checkout_containers(_api::ContainersApi, response_stream::Channel; containers_checkout=nothing, _mediaType=nothing)
    _ctx = _oacinternal_checkout_containers(_api; containers_checkout=containers_checkout, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_create_container_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => Container,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_create_container(_api::ContainersApi; container_create=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_create_container_ContainersApi, "/containers", ["basicApiKeyAuth", "oAuth", ], container_create)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Create a new container

Create a new container

Params:
- container_create::ContainerCreate

Return: Container, OpenAPI.Clients.ApiResponse
"""
function create_container(_api::ContainersApi; container_create=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_container(_api; container_create=container_create, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function create_container(_api::ContainersApi, response_stream::Channel; container_create=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_container(_api; container_create=container_create, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_delete_container_content_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("204", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_delete_container_content(_api::ContainersApi, container_id::String, containable_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_delete_container_content_ContainersApi, "/containers/{container_id}/contents/{containable_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "container_id", container_id)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "containable_id", containable_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Delete a container content

Delete a container content

Params:
- container_id::String (required)
- containable_id::String (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function delete_container_content(_api::ContainersApi, container_id::String, containable_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_container_content(_api, container_id, containable_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function delete_container_content(_api::ContainersApi, response_stream::Channel, container_id::String, containable_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_container_content(_api, container_id, containable_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_container_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Container,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_container(_api::ContainersApi, container_id::String; returning=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_container_ContainersApi, "/containers/{container_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "container_id", container_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "returning", returning)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""get a container by id

get a container by id

Params:
- container_id::String (required)
- returning::String

Return: Container, OpenAPI.Clients.ApiResponse
"""
function get_container(_api::ContainersApi, container_id::String; returning=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_container(_api, container_id; returning=returning, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_container(_api::ContainersApi, response_stream::Channel, container_id::String; returning=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_container(_api, container_id; returning=returning, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_container_content_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainerContent,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_get_container_content(_api::ContainersApi, container_id::String, containable_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_container_content_ContainersApi, "/containers/{container_id}/contents/{containable_id}", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "container_id", container_id)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "containable_id", containable_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a container content

Get a container content

Params:
- container_id::String (required)
- containable_id::String (required)

Return: ContainerContent, OpenAPI.Clients.ApiResponse
"""
function get_container_content(_api::ContainersApi, container_id::String, containable_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_container_content(_api, container_id, containable_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_container_content(_api::ContainersApi, response_stream::Channel, container_id::String, containable_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_container_content(_api, container_id, containable_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_container_contents_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainerContentsList,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_list_container_contents(_api::ContainersApi, container_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_container_contents_ContainersApi, "/containers/{container_id}/contents", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "container_id", container_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List a container's contents

List a container's contents

Params:
- container_id::String (required)

Return: ContainerContentsList, OpenAPI.Clients.ApiResponse
"""
function list_container_contents(_api::ContainersApi, container_id::String; _mediaType=nothing)
    _ctx = _oacinternal_list_container_contents(_api, container_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_container_contents(_api::ContainersApi, response_stream::Channel, container_id::String; _mediaType=nothing)
    _ctx = _oacinternal_list_container_contents(_api, container_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainersPaginatedList,
    Regex("^" * replace("400", "x"=>".") * "\$") => ListContainers400Response,
)

function _oacinternal_list_containers(_api::ContainersApi; page_size=nothing, next_token=nothing, sort=nothing, schema_id=nothing, schema_fields=nothing, modified_at=nothing, name=nothing, name_includes=nothing, ancestor_storage_id=nothing, storage_contents_id=nothing, storage_contents_ids=nothing, archive_reason=nothing, checkout_status=nothing, checkout_assignee_ids_any_of=nothing, restriction_status=nothing, sample_owner_ids_all_of=nothing, sample_owner_ids_any_of=nothing, sample_owner_ids_none_of=nothing, restricted_sample_party_ids_all_of=nothing, restricted_sample_party_ids_any_of=nothing, restricted_sample_party_ids_none_of=nothing, ids=nothing, barcodes=nothing, names_any_of=nothing, names_any_of_case_sensitive=nothing, creator_ids=nothing, returning=nothing, _mediaType=nothing)
    OpenAPI.validate_param("page_size", "list_containers", :maximum, page_size, 100, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_containers_ContainersApi, "/containers", ["basicApiKeyAuth", "oAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "nextToken", next_token)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "sort", sort)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "schemaId", schema_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "schemaFields", schema_fields)  # type Dict{String, Any}
    OpenAPI.Clients.set_param(_ctx.query, "modifiedAt", modified_at)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "name", name)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "nameIncludes", name_includes)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "ancestorStorageId", ancestor_storage_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "storageContentsId", storage_contents_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "storageContentsIds", storage_contents_ids)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "archiveReason", archive_reason)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "checkoutStatus", checkout_status)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "checkoutAssigneeIds.anyOf", checkout_assignee_ids_any_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "restrictionStatus", restriction_status)  # type SampleRestrictionStatus
    OpenAPI.Clients.set_param(_ctx.query, "sampleOwnerIds.allOf", sample_owner_ids_all_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "sampleOwnerIds.anyOf", sample_owner_ids_any_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "sampleOwnerIds.noneOf", sample_owner_ids_none_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "restrictedSamplePartyIds.allOf", restricted_sample_party_ids_all_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "restrictedSamplePartyIds.anyOf", restricted_sample_party_ids_any_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "restrictedSamplePartyIds.noneOf", restricted_sample_party_ids_none_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "ids", ids)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "barcodes", barcodes)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "names.anyOf", names_any_of)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "names.anyOf.caseSensitive", names_any_of_case_sensitive)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "creatorIds", creator_ids)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "returning", returning)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List containers

List containers

Params:
- page_size::Int64
- next_token::String
- sort::String
- schema_id::String
- schema_fields::Dict{String, Any}
- modified_at::String
- name::String
- name_includes::String
- ancestor_storage_id::String
- storage_contents_id::String
- storage_contents_ids::String
- archive_reason::String
- checkout_status::String
- checkout_assignee_ids_any_of::String
- restriction_status::SampleRestrictionStatus
- sample_owner_ids_all_of::String
- sample_owner_ids_any_of::String
- sample_owner_ids_none_of::String
- restricted_sample_party_ids_all_of::String
- restricted_sample_party_ids_any_of::String
- restricted_sample_party_ids_none_of::String
- ids::String
- barcodes::String
- names_any_of::String
- names_any_of_case_sensitive::String
- creator_ids::String
- returning::String

Return: ContainersPaginatedList, OpenAPI.Clients.ApiResponse
"""
function list_containers(_api::ContainersApi; page_size=nothing, next_token=nothing, sort=nothing, schema_id=nothing, schema_fields=nothing, modified_at=nothing, name=nothing, name_includes=nothing, ancestor_storage_id=nothing, storage_contents_id=nothing, storage_contents_ids=nothing, archive_reason=nothing, checkout_status=nothing, checkout_assignee_ids_any_of=nothing, restriction_status=nothing, sample_owner_ids_all_of=nothing, sample_owner_ids_any_of=nothing, sample_owner_ids_none_of=nothing, restricted_sample_party_ids_all_of=nothing, restricted_sample_party_ids_any_of=nothing, restricted_sample_party_ids_none_of=nothing, ids=nothing, barcodes=nothing, names_any_of=nothing, names_any_of_case_sensitive=nothing, creator_ids=nothing, returning=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_containers(_api; page_size=page_size, next_token=next_token, sort=sort, schema_id=schema_id, schema_fields=schema_fields, modified_at=modified_at, name=name, name_includes=name_includes, ancestor_storage_id=ancestor_storage_id, storage_contents_id=storage_contents_id, storage_contents_ids=storage_contents_ids, archive_reason=archive_reason, checkout_status=checkout_status, checkout_assignee_ids_any_of=checkout_assignee_ids_any_of, restriction_status=restriction_status, sample_owner_ids_all_of=sample_owner_ids_all_of, sample_owner_ids_any_of=sample_owner_ids_any_of, sample_owner_ids_none_of=sample_owner_ids_none_of, restricted_sample_party_ids_all_of=restricted_sample_party_ids_all_of, restricted_sample_party_ids_any_of=restricted_sample_party_ids_any_of, restricted_sample_party_ids_none_of=restricted_sample_party_ids_none_of, ids=ids, barcodes=barcodes, names_any_of=names_any_of, names_any_of_case_sensitive=names_any_of_case_sensitive, creator_ids=creator_ids, returning=returning, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_containers(_api::ContainersApi, response_stream::Channel; page_size=nothing, next_token=nothing, sort=nothing, schema_id=nothing, schema_fields=nothing, modified_at=nothing, name=nothing, name_includes=nothing, ancestor_storage_id=nothing, storage_contents_id=nothing, storage_contents_ids=nothing, archive_reason=nothing, checkout_status=nothing, checkout_assignee_ids_any_of=nothing, restriction_status=nothing, sample_owner_ids_all_of=nothing, sample_owner_ids_any_of=nothing, sample_owner_ids_none_of=nothing, restricted_sample_party_ids_all_of=nothing, restricted_sample_party_ids_any_of=nothing, restricted_sample_party_ids_none_of=nothing, ids=nothing, barcodes=nothing, names_any_of=nothing, names_any_of_case_sensitive=nothing, creator_ids=nothing, returning=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_containers(_api; page_size=page_size, next_token=next_token, sort=sort, schema_id=schema_id, schema_fields=schema_fields, modified_at=modified_at, name=name, name_includes=name_includes, ancestor_storage_id=ancestor_storage_id, storage_contents_id=storage_contents_id, storage_contents_ids=storage_contents_ids, archive_reason=archive_reason, checkout_status=checkout_status, checkout_assignee_ids_any_of=checkout_assignee_ids_any_of, restriction_status=restriction_status, sample_owner_ids_all_of=sample_owner_ids_all_of, sample_owner_ids_any_of=sample_owner_ids_any_of, sample_owner_ids_none_of=sample_owner_ids_none_of, restricted_sample_party_ids_all_of=restricted_sample_party_ids_all_of, restricted_sample_party_ids_any_of=restricted_sample_party_ids_any_of, restricted_sample_party_ids_none_of=restricted_sample_party_ids_none_of, ids=ids, barcodes=barcodes, names_any_of=names_any_of, names_any_of_case_sensitive=names_any_of_case_sensitive, creator_ids=creator_ids, returning=returning, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_print_labels_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Any,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_print_labels(_api::ContainersApi; print_labels_param=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_print_labels_ContainersApi, "/containers:print-labels", ["basicApiKeyAuth", "oAuth", ], print_labels_param)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Print labels

Print labels. Supported print methods are \"REMOTE_PRINT_SERVER\", \"LEGACY_HTTP\", and \"LEGACY_TCP\".

Params:
- print_labels_param::PrintLabels

Return: Any, OpenAPI.Clients.ApiResponse
"""
function print_labels(_api::ContainersApi; print_labels_param=nothing, _mediaType=nothing)
    _ctx = _oacinternal_print_labels(_api; print_labels_param=print_labels_param, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function print_labels(_api::ContainersApi, response_stream::Channel; print_labels_param=nothing, _mediaType=nothing)
    _ctx = _oacinternal_print_labels(_api; print_labels_param=print_labels_param, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_reserve_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Any,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
)

function _oacinternal_reserve_containers(_api::ContainersApi; containers_checkout=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_reserve_containers_ContainersApi, "/containers:reserve", ["basicApiKeyAuth", "oAuth", ], containers_checkout)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Reserve containers

Reserve containers to signify that someone plans to use the containers.

Params:
- containers_checkout::ContainersCheckout

Return: Any, OpenAPI.Clients.ApiResponse
"""
function reserve_containers(_api::ContainersApi; containers_checkout=nothing, _mediaType=nothing)
    _ctx = _oacinternal_reserve_containers(_api; containers_checkout=containers_checkout, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function reserve_containers(_api::ContainersApi, response_stream::Channel; containers_checkout=nothing, _mediaType=nothing)
    _ctx = _oacinternal_reserve_containers(_api; containers_checkout=containers_checkout, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_transfer_into_container_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Any,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
)

function _oacinternal_transfer_into_container(_api::ContainersApi, destination_container_id::String; container_transfer=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_transfer_into_container_ContainersApi, "/containers/{destination_container_id}:transfer", ["basicApiKeyAuth", "oAuth", ], container_transfer)
    OpenAPI.Clients.set_param(_ctx.path, "destination_container_id", destination_container_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Transfer into container

Transfers a volume of an entity, batch, or container into a destination container. Transfering a volume is cumulative with the existing destination container's contents. To transfer an entire container's contents, the sourceContainerId should be specified. To otherwise transfer multiple entities within a container, you can make multiple calls to this endpoint, specifying a single entity with each call. 

Params:
- destination_container_id::String (required)
- container_transfer::ContainerTransfer

Return: Any, OpenAPI.Clients.ApiResponse
"""
function transfer_into_container(_api::ContainersApi, destination_container_id::String; container_transfer=nothing, _mediaType=nothing)
    _ctx = _oacinternal_transfer_into_container(_api, destination_container_id; container_transfer=container_transfer, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function transfer_into_container(_api::ContainersApi, response_stream::Channel, destination_container_id::String; container_transfer=nothing, _mediaType=nothing)
    _ctx = _oacinternal_transfer_into_container(_api, destination_container_id; container_transfer=container_transfer, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_transfer_into_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("202", "x"=>".") * "\$") => AsyncTaskLink,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_transfer_into_containers(_api::ContainersApi; multiple_containers_transfers_list=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_transfer_into_containers_ContainersApi, "/transfers", ["basicApiKeyAuth", "oAuth", ], multiple_containers_transfers_list)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Transfers into containers

Transfers a volume of an entity, batch, or container into a destination container. Limit of 5000 transfers per request. Concentration of all contents in the destination container will be automatically updated based on the previous volume & concentrations of the contents in that container, the concentration of the contents being transferred in, the volume of the contents being transferred in, and the final volume of the container. If no concentration is specified, the concentration will not be tracked. 

Params:
- multiple_containers_transfers_list::MultipleContainersTransfersList

Return: AsyncTaskLink, OpenAPI.Clients.ApiResponse
"""
function transfer_into_containers(_api::ContainersApi; multiple_containers_transfers_list=nothing, _mediaType=nothing)
    _ctx = _oacinternal_transfer_into_containers(_api; multiple_containers_transfers_list=multiple_containers_transfers_list, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function transfer_into_containers(_api::ContainersApi, response_stream::Channel; multiple_containers_transfers_list=nothing, _mediaType=nothing)
    _ctx = _oacinternal_transfer_into_containers(_api; multiple_containers_transfers_list=multiple_containers_transfers_list, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_unarchive_containers_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainersArchivalChange,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
)

function _oacinternal_unarchive_containers(_api::ContainersApi; containers_unarchive=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_unarchive_containers_ContainersApi, "/containers:unarchive", ["basicApiKeyAuth", "oAuth", ], containers_unarchive)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Unarchive containers

Unarchive containers

Params:
- containers_unarchive::ContainersUnarchive

Return: ContainersArchivalChange, OpenAPI.Clients.ApiResponse
"""
function unarchive_containers(_api::ContainersApi; containers_unarchive=nothing, _mediaType=nothing)
    _ctx = _oacinternal_unarchive_containers(_api; containers_unarchive=containers_unarchive, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function unarchive_containers(_api::ContainersApi, response_stream::Channel; containers_unarchive=nothing, _mediaType=nothing)
    _ctx = _oacinternal_unarchive_containers(_api; containers_unarchive=containers_unarchive, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_container_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Container,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_update_container(_api::ContainersApi, container_id::String; container_update=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PATCH", _returntypes_update_container_ContainersApi, "/containers/{container_id}", ["basicApiKeyAuth", "oAuth", ], container_update)
    OpenAPI.Clients.set_param(_ctx.path, "container_id", container_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""update a container

update a container

Params:
- container_id::String (required)
- container_update::ContainerUpdate

Return: Container, OpenAPI.Clients.ApiResponse
"""
function update_container(_api::ContainersApi, container_id::String; container_update=nothing, _mediaType=nothing)
    _ctx = _oacinternal_update_container(_api, container_id; container_update=container_update, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_container(_api::ContainersApi, response_stream::Channel, container_id::String; container_update=nothing, _mediaType=nothing)
    _ctx = _oacinternal_update_container(_api, container_id; container_update=container_update, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_container_content_ContainersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ContainerContent,
    Regex("^" * replace("400", "x"=>".") * "\$") => BadRequestError,
    Regex("^" * replace("403", "x"=>".") * "\$") => ForbiddenRestrictedSampleError,
    Regex("^" * replace("404", "x"=>".") * "\$") => NotFoundError,
)

function _oacinternal_update_container_content(_api::ContainersApi, container_id::String, containable_id::String; container_content_update=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PATCH", _returntypes_update_container_content_ContainersApi, "/containers/{container_id}/contents/{containable_id}", ["basicApiKeyAuth", "oAuth", ], container_content_update)
    OpenAPI.Clients.set_param(_ctx.path, "container_id", container_id)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "containable_id", containable_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update a container content

Update a container content

Params:
- container_id::String (required)
- containable_id::String (required)
- container_content_update::ContainerContentUpdate

Return: ContainerContent, OpenAPI.Clients.ApiResponse
"""
function update_container_content(_api::ContainersApi, container_id::String, containable_id::String; container_content_update=nothing, _mediaType=nothing)
    _ctx = _oacinternal_update_container_content(_api, container_id, containable_id; container_content_update=container_content_update, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_container_content(_api::ContainersApi, response_stream::Channel, container_id::String, containable_id::String; container_content_update=nothing, _mediaType=nothing)
    _ctx = _oacinternal_update_container_content(_api, container_id, containable_id; container_content_update=container_content_update, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export archive_containers
export bulk_create_containers
export bulk_get_containers
export bulk_update_containers
export checkin_containers
export checkout_containers
export create_container
export delete_container_content
export get_container
export get_container_content
export list_container_contents
export list_containers
export print_labels
export reserve_containers
export transfer_into_container
export transfer_into_containers
export unarchive_containers
export update_container
export update_container_content
